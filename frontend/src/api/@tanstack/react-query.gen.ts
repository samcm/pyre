// This file is auto-generated by @hey-api/openapi-ts

import {
  type DefaultError,
  type InfiniteData,
  infiniteQueryOptions,
  queryOptions,
  type UseMutationOptions,
} from '@tanstack/react-query';

import { client } from '../client.gen';
import {
  backfillUserPnl,
  getLeaderboard,
  getPersona,
  getPersonaAccounts,
  getPersonaLeaderboard,
  getPersonaPositions,
  getPersonaResults,
  getPersonas,
  getPersonaTrades,
  getTrades,
  getUser,
  getUserPnl,
  getUserPositions,
  getUserResults,
  getUsers,
  getUserTrades,
  type Options,
  triggerSync,
} from '../sdk.gen';
import type {
  BackfillUserPnlData,
  BackfillUserPnlResponse,
  GetLeaderboardData,
  GetLeaderboardResponse,
  GetPersonaAccountsData,
  GetPersonaAccountsResponse,
  GetPersonaData,
  GetPersonaLeaderboardData,
  GetPersonaLeaderboardResponse,
  GetPersonaPositionsData,
  GetPersonaPositionsResponse,
  GetPersonaResponse,
  GetPersonaResultsData,
  GetPersonaResultsResponse,
  GetPersonasData,
  GetPersonasResponse,
  GetPersonaTradesData,
  GetPersonaTradesResponse,
  GetTradesData,
  GetTradesResponse,
  GetUserData,
  GetUserPnlData,
  GetUserPnlResponse,
  GetUserPositionsData,
  GetUserPositionsResponse,
  GetUserResponse,
  GetUserResultsData,
  GetUserResultsResponse,
  GetUsersData,
  GetUsersResponse,
  GetUserTradesData,
  GetUserTradesResponse,
  TriggerSyncData,
} from '../types.gen';

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const getUsersQueryKey = (options?: Options<GetUsersData>) => createQueryKey('getUsers', options);

/**
 * Get all tracked users
 */
export const getUsersOptions = (options?: Options<GetUsersData>) =>
  queryOptions<GetUsersResponse, DefaultError, GetUsersResponse, ReturnType<typeof getUsersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUsersQueryKey(options),
  });

export const getUserQueryKey = (options: Options<GetUserData>) => createQueryKey('getUser', options);

/**
 * Get user details
 */
export const getUserOptions = (options: Options<GetUserData>) =>
  queryOptions<GetUserResponse, DefaultError, GetUserResponse, ReturnType<typeof getUserQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserQueryKey(options),
  });

export const getUserPositionsQueryKey = (options: Options<GetUserPositionsData>) =>
  createQueryKey('getUserPositions', options);

/**
 * Get user's current positions
 */
export const getUserPositionsOptions = (options: Options<GetUserPositionsData>) =>
  queryOptions<
    GetUserPositionsResponse,
    DefaultError,
    GetUserPositionsResponse,
    ReturnType<typeof getUserPositionsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserPositions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserPositionsQueryKey(options),
  });

export const getUserTradesQueryKey = (options: Options<GetUserTradesData>) => createQueryKey('getUserTrades', options);

/**
 * Get user's trade history
 */
export const getUserTradesOptions = (options: Options<GetUserTradesData>) =>
  queryOptions<GetUserTradesResponse, DefaultError, GetUserTradesResponse, ReturnType<typeof getUserTradesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserTrades({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserTradesQueryKey(options),
  });

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(
  queryKey: QueryKey<Options>,
  page: K,
) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const getUserTradesInfiniteQueryKey = (
  options: Options<GetUserTradesData>,
): QueryKey<Options<GetUserTradesData>> => createQueryKey('getUserTrades', options, true);

/**
 * Get user's trade history
 */
export const getUserTradesInfiniteOptions = (options: Options<GetUserTradesData>) => {
  return infiniteQueryOptions<
    GetUserTradesResponse,
    DefaultError,
    InfiniteData<GetUserTradesResponse>,
    QueryKey<Options<GetUserTradesData>>,
    number | Pick<QueryKey<Options<GetUserTradesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetUserTradesData>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUserTrades({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUserTradesInfiniteQueryKey(options),
    },
  );
};

export const getUserPnlQueryKey = (options: Options<GetUserPnlData>) => createQueryKey('getUserPnl', options);

/**
 * Get user's PNL history
 */
export const getUserPnlOptions = (options: Options<GetUserPnlData>) =>
  queryOptions<GetUserPnlResponse, DefaultError, GetUserPnlResponse, ReturnType<typeof getUserPnlQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getUserPnl({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getUserPnlQueryKey(options),
  });

export const getUserPnlInfiniteQueryKey = (options: Options<GetUserPnlData>): QueryKey<Options<GetUserPnlData>> =>
  createQueryKey('getUserPnl', options, true);

/**
 * Get user's PNL history
 */
export const getUserPnlInfiniteOptions = (options: Options<GetUserPnlData>) => {
  return infiniteQueryOptions<
    GetUserPnlResponse,
    DefaultError,
    InfiniteData<GetUserPnlResponse>,
    QueryKey<Options<GetUserPnlData>>,
    string | Pick<QueryKey<Options<GetUserPnlData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetUserPnlData>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  start: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUserPnl({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUserPnlInfiniteQueryKey(options),
    },
  );
};

export const getUserResultsQueryKey = (options: Options<GetUserResultsData>) =>
  createQueryKey('getUserResults', options);

/**
 * Get user's resolved positions (results)
 */
export const getUserResultsOptions = (options: Options<GetUserResultsData>) =>
  queryOptions<GetUserResultsResponse, DefaultError, GetUserResultsResponse, ReturnType<typeof getUserResultsQueryKey>>(
    {
      queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUserResults({
          ...options,
          ...queryKey[0],
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUserResultsQueryKey(options),
    },
  );

export const getUserResultsInfiniteQueryKey = (
  options: Options<GetUserResultsData>,
): QueryKey<Options<GetUserResultsData>> => createQueryKey('getUserResults', options, true);

/**
 * Get user's resolved positions (results)
 */
export const getUserResultsInfiniteOptions = (options: Options<GetUserResultsData>) => {
  return infiniteQueryOptions<
    GetUserResultsResponse,
    DefaultError,
    InfiniteData<GetUserResultsResponse>,
    QueryKey<Options<GetUserResultsData>>,
    number | Pick<QueryKey<Options<GetUserResultsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetUserResultsData>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getUserResults({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getUserResultsInfiniteQueryKey(options),
    },
  );
};

/**
 * Backfill PNL history from trade data using FIFO cost basis
 *
 * Reconstructs historical PNL by processing all trades chronologically.
 * Uses FIFO (First-In-First-Out) cost basis to calculate realized PNL.
 * Generates daily snapshots of cumulative realized PNL.
 *
 */
export const backfillUserPnlMutation = (
  options?: Partial<Options<BackfillUserPnlData>>,
): UseMutationOptions<BackfillUserPnlResponse, DefaultError, Options<BackfillUserPnlData>> => {
  const mutationOptions: UseMutationOptions<BackfillUserPnlResponse, DefaultError, Options<BackfillUserPnlData>> = {
    mutationFn: async fnOptions => {
      const { data } = await backfillUserPnl({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getTradesQueryKey = (options?: Options<GetTradesData>) => createQueryKey('getTrades', options);

/**
 * Get all recent trades with filtering
 */
export const getTradesOptions = (options?: Options<GetTradesData>) =>
  queryOptions<GetTradesResponse, DefaultError, GetTradesResponse, ReturnType<typeof getTradesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getTrades({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getTradesQueryKey(options),
  });

export const getTradesInfiniteQueryKey = (options?: Options<GetTradesData>): QueryKey<Options<GetTradesData>> =>
  createQueryKey('getTrades', options, true);

/**
 * Get all recent trades with filtering
 */
export const getTradesInfiniteOptions = (options?: Options<GetTradesData>) => {
  return infiniteQueryOptions<
    GetTradesResponse,
    DefaultError,
    InfiniteData<GetTradesResponse>,
    QueryKey<Options<GetTradesData>>,
    number | Pick<QueryKey<Options<GetTradesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetTradesData>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getTrades({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getTradesInfiniteQueryKey(options),
    },
  );
};

export const getLeaderboardQueryKey = (options?: Options<GetLeaderboardData>) =>
  createQueryKey('getLeaderboard', options);

/**
 * Get leaderboard of all users
 */
export const getLeaderboardOptions = (options?: Options<GetLeaderboardData>) =>
  queryOptions<GetLeaderboardResponse, DefaultError, GetLeaderboardResponse, ReturnType<typeof getLeaderboardQueryKey>>(
    {
      queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLeaderboard({
          ...options,
          ...queryKey[0],
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getLeaderboardQueryKey(options),
    },
  );

/**
 * Trigger a sync of all user data
 */
export const triggerSyncMutation = (
  options?: Partial<Options<TriggerSyncData>>,
): UseMutationOptions<unknown, DefaultError, Options<TriggerSyncData>> => {
  const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<TriggerSyncData>> = {
    mutationFn: async fnOptions => {
      const { data } = await triggerSync({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getPersonasQueryKey = (options?: Options<GetPersonasData>) => createQueryKey('getPersonas', options);

/**
 * Get all personas (real people mapped to usernames)
 */
export const getPersonasOptions = (options?: Options<GetPersonasData>) =>
  queryOptions<GetPersonasResponse, DefaultError, GetPersonasResponse, ReturnType<typeof getPersonasQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPersonas({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPersonasQueryKey(options),
  });

export const getPersonaQueryKey = (options: Options<GetPersonaData>) => createQueryKey('getPersona', options);

/**
 * Get persona details with aggregated stats
 */
export const getPersonaOptions = (options: Options<GetPersonaData>) =>
  queryOptions<GetPersonaResponse, DefaultError, GetPersonaResponse, ReturnType<typeof getPersonaQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPersona({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPersonaQueryKey(options),
  });

export const getPersonaAccountsQueryKey = (options: Options<GetPersonaAccountsData>) =>
  createQueryKey('getPersonaAccounts', options);

/**
 * Get all accounts for a persona with individual stats
 */
export const getPersonaAccountsOptions = (options: Options<GetPersonaAccountsData>) =>
  queryOptions<
    GetPersonaAccountsResponse,
    DefaultError,
    GetPersonaAccountsResponse,
    ReturnType<typeof getPersonaAccountsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPersonaAccounts({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPersonaAccountsQueryKey(options),
  });

export const getPersonaLeaderboardQueryKey = (options?: Options<GetPersonaLeaderboardData>) =>
  createQueryKey('getPersonaLeaderboard', options);

/**
 * Get leaderboard by persona (aggregated stats)
 */
export const getPersonaLeaderboardOptions = (options?: Options<GetPersonaLeaderboardData>) =>
  queryOptions<
    GetPersonaLeaderboardResponse,
    DefaultError,
    GetPersonaLeaderboardResponse,
    ReturnType<typeof getPersonaLeaderboardQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPersonaLeaderboard({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPersonaLeaderboardQueryKey(options),
  });

export const getPersonaPositionsQueryKey = (options: Options<GetPersonaPositionsData>) =>
  createQueryKey('getPersonaPositions', options);

/**
 * Get combined positions across all accounts for a persona
 */
export const getPersonaPositionsOptions = (options: Options<GetPersonaPositionsData>) =>
  queryOptions<
    GetPersonaPositionsResponse,
    DefaultError,
    GetPersonaPositionsResponse,
    ReturnType<typeof getPersonaPositionsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPersonaPositions({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPersonaPositionsQueryKey(options),
  });

export const getPersonaTradesQueryKey = (options: Options<GetPersonaTradesData>) =>
  createQueryKey('getPersonaTrades', options);

/**
 * Get combined trades across all accounts for a persona
 */
export const getPersonaTradesOptions = (options: Options<GetPersonaTradesData>) =>
  queryOptions<
    GetPersonaTradesResponse,
    DefaultError,
    GetPersonaTradesResponse,
    ReturnType<typeof getPersonaTradesQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPersonaTrades({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPersonaTradesQueryKey(options),
  });

export const getPersonaTradesInfiniteQueryKey = (
  options: Options<GetPersonaTradesData>,
): QueryKey<Options<GetPersonaTradesData>> => createQueryKey('getPersonaTrades', options, true);

/**
 * Get combined trades across all accounts for a persona
 */
export const getPersonaTradesInfiniteOptions = (options: Options<GetPersonaTradesData>) => {
  return infiniteQueryOptions<
    GetPersonaTradesResponse,
    DefaultError,
    InfiniteData<GetPersonaTradesResponse>,
    QueryKey<Options<GetPersonaTradesData>>,
    number | Pick<QueryKey<Options<GetPersonaTradesData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPersonaTradesData>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPersonaTrades({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getPersonaTradesInfiniteQueryKey(options),
    },
  );
};

export const getPersonaResultsQueryKey = (options: Options<GetPersonaResultsData>) =>
  createQueryKey('getPersonaResults', options);

/**
 * Get combined resolved positions (results) across all accounts for a persona
 */
export const getPersonaResultsOptions = (options: Options<GetPersonaResultsData>) =>
  queryOptions<
    GetPersonaResultsResponse,
    DefaultError,
    GetPersonaResultsResponse,
    ReturnType<typeof getPersonaResultsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getPersonaResults({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getPersonaResultsQueryKey(options),
  });

export const getPersonaResultsInfiniteQueryKey = (
  options: Options<GetPersonaResultsData>,
): QueryKey<Options<GetPersonaResultsData>> => createQueryKey('getPersonaResults', options, true);

/**
 * Get combined resolved positions (results) across all accounts for a persona
 */
export const getPersonaResultsInfiniteOptions = (options: Options<GetPersonaResultsData>) => {
  return infiniteQueryOptions<
    GetPersonaResultsResponse,
    DefaultError,
    InfiniteData<GetPersonaResultsResponse>,
    QueryKey<Options<GetPersonaResultsData>>,
    number | Pick<QueryKey<Options<GetPersonaResultsData>>[0], 'body' | 'headers' | 'path' | 'query'>
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetPersonaResultsData>>[0], 'body' | 'headers' | 'path' | 'query'> =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  offset: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getPersonaResults({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: getPersonaResultsInfiniteQueryKey(options),
    },
  );
};
